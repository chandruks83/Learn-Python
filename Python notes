Dynamic Typing
--------------
Python uses dynamic typing, meaning you can reassign variables to different data types. This makes Python very flexible in assigning data types; it differs from other languages that are statically typed.

Determining variable type with type()
You can check what type of object is assigned to a variable using Python's built-in type() function. Common data types include:

int (for integer)
float
str (for string)
list
tuple
dict (for dictionary)
set
bool (for Boolean True/False)

Numbers
---------
7/4		1.75
7//4	1
2**3	8
4**0.5	2

pstr = "HelloWorld"

Strings
--------
Command		Results
pstr[0]		H
len(pstr)   10
pstr[:]		HelloWorld
pstr[2:]	lloWorld
pstr[:3]	Hel
pstr[2:5]	llo (Except the last character.ie.,5th character)
pstr[2:9:2]	lool (Extract every 2nd character from 2nd position till 9th)
pstr[:-1] 	HelloWorl (Except the last character)
pstr[::-1]  dlroWolleH (Reverse a string)
"abc"[0]	a
len('abcd')	4

Strings are immutable, this means that once a string is created, the elements within it can not be changed or replaced
e.g., s='abcd'
	  s[0] = 'z'	  Not possible, will error

s=s+'bcd'		abcdbcd
s*2				abcdbcdabcdbcd         String multiplication

s='A,B,C,D'

s.upper()
s.lower()
s.islower
s.isupper
s.split(',')
s.title() - converts to title case
s.startswith()
s.endswith()
'Hello'.rjust(5,'*') -> *****Hello
'Hello'.ljust(5,'-') -> Hello-----
'Hello'.center(5,'=') -> =====Hello=====
' x '.strip() ->'x'  removes white spaces
'xyzxy'.strip('xy') -> 'z'        removes the specified characters from both the sides until it reaches unspecified character
'abcadea'.replace('a','z') ->'zbczdez'

''.join(['a','b','c']) -> abc
' '.join(['a','b','c']) -> a b c
','.join(['a','b','c']) -> a,b,c
'\n'.join(['a','b','c']) -> a
							b
							c

Methods returning boolean

isalpha() - letters only
isalnum() - letters and numbers
isdecimal() - numbers only
isspace() - whitespace only
istitle() - titelcase only


String formatting
-----------------
a=10.5
b=5
r='rep'
print('This is a %s %r %1.2f and %d string'%('formatted',r,a,b))		This is a formatted 'rep' 10.50 and 5 string

print('This is a {}'.format('string'))   				This is a string
print('This is a {0} {1}'.format('brown', 'fox'))   	This is a brown fox
print('This is a {b} {f}'.format(b='brown', f='fox'))	This is a brown fox

name = 'Vedanth'
age = '2'
print(f'My name is {name}, age is {age}')				My name is Vedanth, age is 2

Float formatting follows "{value:width.precission f}"
E.g.,	result = 10/7
		print result									1.4285714285714286
		print('Result is {r:1.5f}'.format(r=result))	Result is 1.42857
		
place = 'bangalore'
name = 'sachin'
'my name is %s and place is %s' %(name, place)
'my name is sachin and place is bangalore'

Lists
---------
Lists can contain elements of multiple datatypes
l1=[1, 'a', 2]
l2=[2,3]
l3=l1+l2
l1.append('b')
l1=['b', 'a', 'x','z']
l1.sort()												['a', 'b', 'x', 'z']
l1[::-1]												['z', 'x', 'b', 'a']
l1.reverse()											['z', 'x', 'b', 'a']
l2=[1,2]
l1.append(l2)
l1[4][1]												2
l1.pop													z
l1.pop(1)												a

s=['a','b','c']
del s[1]
print(s)
['a', 'c']

cat = [1,2,3]
a,b,c=cat
print(a) --->1
print(b)--->2
print(c)--->3


Dictionaries
-------------
Dictionaries are unordered key-value pairs
dict = {'key1':'value1', 'key2':'value2'}
e.g.,
dp =
{'apple': 100,
 'banana': 5,
 'veg': {'carrot': 10, 'bean': 20},
 'count': [1, 2, 3]}
dp['apple']												10
dp['veg']['carrot']										10

Methods :
keys()
values()
items()
get()
setdefault()
pprint()
pformat()

Tuples
---------
Tuples are similar to list with but with 
common brackets and tuples are immutable
t=(1,2,3,2)
t.count(2)												2
t.index(2)												1
t=(1,2,[1,2])
t[2][1]													2

Sets
------
Sets are unordered collection of unique elements
No duplicates
s=set()
s.add(1)
set('parallel')											{'p', 'a', 'r','l','e'}

File i/o
---------

with open('myfile.txt', mode='w') as myfile:
    myfile.write('New line')

with open('myfile.txt', mode='r') as myfile:
    print(myfile.read())
	
The above syntax of "with open" will close the file after the line is executed

Reading, writing and appending modes

* mode = 'r' - read only
* mode = 'w' - write only (Will overwrtie files or create new)
* mode = 'a' - append only (Will addon to files)
* mode = 'r+' - reading and writing
* mode = 'w+' - writing and reading(overwrites existing or creates new)

Control flow
-------------
a = 2
b=1
if a < b :
    print("a less than b")
elif a > b :
    print("b less than a")
else :
    print("a equal to b") 

For loop

for a in 'abc':											a b c
    print(a)

a = '123'												1 2 3
for a in a:
    print(a)
	
a = [1,2,3,4]											1 2 3 4
for a in a:
    print(a)
	
a = [(1,2), (3,4)]										(1, 2)
for a in a:												(3, 4)
	print(a)

a = [(1,2), (3,4)]										1 2 3 4
for a,b in a:
    print(a)
    print(b)
    
a= {'k':1,'k1':2,'k2':3}								k k1 k2
for i in a:
    print(i)
	
a= {'k':1,'k1':2,'k2':3}								('k', 1)
for i in a.items():										('k1', 2)
    print(i)											('k2', 3)			

a= {'k':1,'k1':2,'k2':3}								1 2 3
for i in a.values():
    print(i)

a= {'k':1,'k1':2,'k2':3}
for i in a.values():
    pass						# Do nothing
print(i)

for i in range(4):										1 2 3
    print(i)
	
for i in range(2,5,2):									2 4
    print(i)

for i in range(-4,1):									-4 -3 -2 -1 0
    print(i)
	
for index in enumerate('abc'):							(0, 'a')
	print(index)										(1, 'b')
														(2, 'c')

for index, letter in enumerate('abc'):					0a 1b 2c
    print(index)
    print(letter)
	
for i in ['a', 'b','c']:
	print(i)

a
b
c

Useful operators
------------------
l1=[1,2]												(1, 'a')
l2=['a', 'b']											(2, 'b')
l3=zip(l1,l2)
for item in l3:
    print(item)														

l1=[1,2]												
l2=['a', 'b']
l3=zip(l1,l2)
list(l3)												[(1, 'a'), (2, 'b')]

'a' in 'abcd'											True

a=[1,2]													
1 in a													True

d={'k':123,'k1':12}
'k' in d												True

d={'k':123,'k1':12}
123 in d.values()										True

d={'k':123,'k1':12}
'k' in d.keys()											True

a=[1,2,3]
min(a)													1	
max(a)													2

from random import shuffle
a=[1,2,3]
shuffle(a)
a														[1,3,2]			

from random import randint
randint(0, 1000)										481

a= int(input('Enter a number'))
print(a)												

a = 5
while a > 1:
    if a == 2:
        continue
    else :
        print(a)
    a = a - 1
	
List comprehensions

t='abcd'	
[x for x in t]											['a', 'b', 'c', 'd']

t=(1,2,3)
[x for x in t]											[1, 2, 3]

[x**2 for x in range(1,10) if x%2==0]					[4, 16, 36, 64]

celcius = [0, 10, 20, 34.5]
farhenheit = [((9/5)*temp) for temp in celcius]			[0.0, 18.0, 36.0, 62.1]

[x*y for x in [2,3,4] for y in [10,20,30]]				[20, 40, 60, 30, 60, 90, 40, 80, 120]

Functions
--------------------------------------------

def LesserEven(a,b):
    if (a%2 == 0 and b%2==0):
        return min(a,b)
    else:
        return max(a,b)

print(LesserEven(1,2))

def old_macdonald(a):
       return ''.join([x.upper() if (a.index(x)==0 or a.index(x)==3) else x for x in a])
	   
map(methodname, paramter to the method) : will return the outputs of the method passed
	def square(num):
		return num**2
	
	n = [1,2,3]
	list(map(square, n))	-------> [1, 4, 9]
	
	for item in map(square,n):
    print(item)             -------> 1, 4, 9

Filter function
	def checkEven(num):
		return num%2 == 0
	
	n = [1,2,3,4,5,6,7,8]
	for item in filter(checkEven,n):
		print(item)
	list(filter(checkEven,n)) 			-------------->  2 4 6 8 
														[2, 4, 6, 8]

Lambda expressions :
	n = [2,3,4,5]
	list(map(lambda num : num**2, n)) -------------> [4, 9, 16, 25]
	
	For each number in n labda expression will return the square of it
	

Try except:

print('How many cats do u have?')
n = input()
try:
    if int(n) >= 4:
        print('You have lot of cats')
    else:
        print('You have less cats')
except ValueError:
    print('Catch value error')

Conversion functions

	* int('42') -->42
	* str(42)	-->'42'	
	* List('Hello') --> ['H','e','l','l','o']
	
In and not in

	* 42 in [1,2,42] --->True
	* 42 not in [1,2,42] --->False

Multiple assignments

a = 'aa'
b = 'bb'

a,b = b,a
print(a) ----> 'bb'
print(b) ----> 'aa'

Range function :
	Range() function returns a list like value, which can be passed to list() to get the actual values

	list(range(0,3))
[0, 1, 2]

Simplify sorting :

c='zxcvasdfsd'
d=list(c)
d.sort()
print(d)
['a', 'c', 'd', 'd', 'f', 's', 's', 'v', 'x', 'z']

Sorting happens in ASCII-betical order, meaning Capital letters gets more priority than small
i.e.,

c = ['a','b','A', 'Z']
c.sort()
print(c)
['A', 'Z', 'a', 'b']
c.sort(key=str.lower)
print(c)
['A', 'a', 'b', 'Z']

Reverse sorting
d.sort(reverse=true)

** Difference between "del" and "remove"
cat = [0, 1, 2, 3]
del cat[0]
print(cat)
[1, 2, 3]
cat.remove(1)
print(cat)
[2, 3]

Lists are accessed by their references

def eggs(cheese):
    cheese.append('Hello')

spam=[1,2,3]
eggs(spam)
print(spam) ------>[1, 2, 3, 'Hello']

To have a copy of a list

import copy
spam=[1,2,3]
cheese = copy.deepcopy(spam)
cheese[0]=0
print(cheese)
[0, 2, 3]
print(spam)
[1, 2, 3]

Line continuation character (\) can be used to stretch python instructions to multiple lines
print('This is an example of '+ \
  'a line strech')
This is an example of a line strech

Commenting multiple lines if code/Strings
	Use triple quotes(''' ''') for multi line commenting, it will also escape the special characters in the code

Escape characters
	"To escape 'apostrophe' use double quotes"
	e.g., "This is Python's doc"
Also using backslash characters can be escaped
e.g., \' (Single quote), \" (Double quote), \t (tab), \n (newline), \\ (Backslash)


Run python scripts without any ide
	Shebangline #! python3
	
Running program from commandline
@py C:\Users\Chandru\git\Learn-Python\PythonScripts\ShebangLine.py %*
@pause

@py - Not to show anything it follows i.e., ignore C:\Users\Chandru\git\Learn-Python\PythonScripts\ShebangLine.py in cmdline
%*  - Take arguments from commandline and pass to python script

Running from a batch file
	* create a batch file with the above contents(Running program from commandline)
	* Add the parent folder of this batch to environment variable path
	* Just type the batch file name from 'run' dialog
	* Pass the arguments to python by placing after the batch file name (eg. rpy arg1 arg2 arg3)
	* Retrieve these arguments using import sys, sys.argv
	
Regular expressions
#Regular expression
str1 = "My Phone number is +91-9889889889 \
           Shilpa's number +91-9986998699"
import re
getphone = re.compile(r'\+\d\d\-\d\d\d\d\d\d\d\d\d\d')
phone = getphone.search(str1)
#Search for one element
print(phone.group())
#output : +91-9889889889

#Search for all the elements
print(getphone.findall(str1))
#output : ['+91-9889889889', '+91-9986998699']

#Grouping of strings using brackets
getphone = re.compile(r'\+(\d\d)\-(\d\d\d\d\d\d\d\d\d\d)')
phone = getphone.search(str1)
print(phone.group(1))
print(phone.group(2))
#output : 91
9889889889

#using pipe character, match any one of the strings
regexWithpipe = re.compile(r'Bat(man|mobile|woman)')
mo = regexWithpipe.search('Batwoman came to rescue and Batman followed')
print(mo.group())
#output : Batwoman

#match 0 or one time using ?
regexp = re.compile(r'Bat(wo)?man')
mo = regexp.search('I am a Batman with a Batwoman')
print(mo.group())
#output : Batman

rx = re.compile(r'(\d\d-)?\d\d\d\d\d\d\d\d\d\d')
mo = rx.search('91-9886688660')
print(mo.group())
mo = rx.search('9886688660')
print(mo.group())
#output : 91-9886688660
9886688660