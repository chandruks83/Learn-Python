Dynamic Typing
--------------
Python uses dynamic typing, meaning you can reassign variables to different data types. This makes Python very flexible in assigning data types; it differs from other languages that are statically typed.

Determining variable type with type()
You can check what type of object is assigned to a variable using Python's built-in type() function. Common data types include:

int (for integer)
float
str (for string)
list
tuple
dict (for dictionary)
set
bool (for Boolean True/False)

Numbers
---------
7/4		1.75
7//4	1
2**3	8
4**0.5	2

pstr = "HelloWorld"

Strings
--------
Command		Results
pstr[0]		H
len(pstr)   10
pstr[:]		HelloWorld
pstr[2:]	He
pstr[:3]	Hel
pstr[2:5]	llo (Except the last character.ie.,5th character)
pstr[2:9:2]	lool (Extract every 2nd character from 2nd position till 9th)
pstr[:-1] 	HelloWorl (Except the last character)
pstr[::-1]  dlroWolleH (Reverse a string)
"abc"[0]	a
len('abcd')	4

Strings are immutable, this means that once a string is created, the elements within it can not be changed or replaced
e.g., s='abcd'
	  s[] = 'z'	  Not possible, will error

s=s+'bcd'		abcdbcd
s*2				abcdbcdabcdbcd         String multiplication

s='A,B,C,D'

s.upper()
s.lower()
s.split(',')

String formatting
-----------------
a=10.5
b=5
r='rep'
print('This is a %s %r %1.2f and %d string'%('formatted',r,a,b))		This is a formatted 'rep' 10.50 and 5 string

print('This is a {}'.format('string'))   				This is a string
print('This is a {0} {1}'.format('brown', 'fox'))   	This is a brown fox
print('This is a {b} {f}'.format(b='brown', f='fox'))	This is a brown fox

name = 'Vedanth'
age = '2'
print(f'My name is {name}, age is {age}')				My name is Vedanth, age is 2

Float formatting follows "{value:width.precission f}"
E.g.,	result = 10/7
		print result									1.4285714285714286
		print('Result is {r:1.5f}'.format(r=result))	Result is 1.42857

Lists
---------
Lists can contain elements of multiple datatypes
l1=[1, 'a', 2]
l2=[2,3]
l3=l1+l2
l1.append('b')
l1=['b', 'a', 'x','z']
l1.sort()												['a', 'b', 'x', 'z']
l1[::-1]												['z', 'x', 'b', 'a']
l1.reverse()											['z', 'x', 'b', 'a']
l2=[1,2]
l1.append(l2)
l1[4][1]												2
l1.pop													z
l1.pop(1)												a

Dictionaries
-------------
Dictionaries are unordered key-value pairs
dict = {'key1':'value1', 'key2':'value2'}
e.g.,
dp =
{'apple': 100,
 'banana': 5,
 'veg': {'carrot': 10, 'bean': 20},
 'count': [1, 2, 3]}
dp['apple']												10
dp['veg']['carrot']										10

Tuples
---------
Tuples are similar to list with but with 
common brackets and tuples are immutable
t=(1,2,3,2)
t.count(2)												2
t.index(2)												1
t=(1,2,[1,2])
t[2][1]													2

Sets
------
Sets are unordered collection of unique elements
No duplicates
s=set()
s.add(1)
set('parallel')											{'p', 'a', 'r','l','e'}

File i/o
---------

with open('myfile.txt', mode='w') as myfile:
    myfile.write('New line')

with open('myfile.txt', mode='r') as myfile:
    print(myfile.read())
	
The above syntax of "with open" will close the file after the line is executed

Reading, writing and appending modes

* mode = 'r' - read only
* mode = 'w' - write only (Will overwrtie files or create new)
* mode = 'a' - append only (Will addon to files)
* mode = 'r+' - reading and writing
* mode = 'w+' - writing and reading(overwrites existing or creates new)

Control flow
-------------
a = 2
b=1
if a < b :
    print("a less than b")
elif a > b :
    print("b less than a")
else :
    print("a equal to b") 

For loop

for a in 'abc':											a b c
    print(a)

a = '123'												1 2 3
for a in a:
    print(a)
	
a = [1,2,3,4]											1 2 3 4
for a in a:
    print(a)
	
a = [(1,2), (3,4)]										(1, 2)
for a in a:												(3, 4)
	print(a)

a = [(1,2), (3,4)]										1 2 3 4
for a,b in a:
    print(a)
    print(b)
    
a= {'k':1,'k1':2,'k2':3}								k k1 k2
for i in a:
    print(i)
	
a= {'k':1,'k1':2,'k2':3}								('k', 1)
for i in a.items():										('k1', 2)
    print(i)											('k2', 3)			

a= {'k':1,'k1':2,'k2':3}								1 2 3
for i in a.values():
    print(i)

a= {'k':1,'k1':2,'k2':3}
for i in a.values():
    pass						# Do nothing
print(i)

for i in range(4):										1 2 3
    print(i)
	
for i in range(2,5,2):									2 4
    print(i)

for i in range(-4,1):									-4 -3 -2 -1 0
    print(i)
	
for index in enumerate('abc'):							(0, 'a')
	print(index)										(1, 'b')
														(2, 'c')

for index, letter in enumerate('abc'):					0a 1b 2c
    print(index)
    print(letter)

Useful operators
------------------
l1=[1,2]												(1, 'a')
l2=['a', 'b']											(2, 'b')
l3=zip(l1,l2)
for item in l3:
    print(item)														

l1=[1,2]												
l2=['a', 'b']
l3=zip(l1,l2)
list(l3)												[(1, 'a'), (2, 'b')]

'a' in 'abcd'											True

a=[1,2]													
1 in a													True

d={'k':123,'k1':12}
'k' in d												True

d={'k':123,'k1':12}
123 in d.values()										True

d={'k':123,'k1':12}
'k' in d.keys()											True

a=[1,2,3]
min(a)													1	
max(a)													2

from random import shuffle
a=[1,2,3]
shuffle(a)
a														[1,3,2]			

from random import randint
randint(0, 1000)										481

a= int(input('Enter a number'))
print(a)												

a = 5
while a > 1:
    if a == 2:
        continue
    else :
        print(a)
    a = a - 1
	
List comprehensions

t='abcd'	
[x for x in t]											['a', 'b', 'c', 'd']

t=(1,2,3)
[x for x in t]											[1, 2, 3]

[x**2 for x in range(1,10) if x%2==0]					[4, 16, 36, 64]

celcius = [0, 10, 20, 34.5]
farhenheit = [((9/5)*temp) for temp in celcius]			[0.0, 18.0, 36.0, 62.1]

[x*y for x in [2,3,4] for y in [10,20,30]]				[20, 40, 60, 30, 60, 90, 40, 80, 120]

